// Generated by CoffeeScript 1.7.1
(function() {
  var ASYNC, FS, TRM, TYPES, alert, bSearch, badge, debug, echo, eventually, help, info, log, moment, njs_fs, njs_path, rpr, warn, whisper;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  FS = require('coffeenode-fs');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/main';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  bSearch = require('coffeenode-bsearch');

  this.options = require('../options');

  eventually = process.nextTick;

  moment = require('moment-timezone');

  ASYNC = require('async');

  this.new_tidal_event = function(source_line_nr, date, is_dst, hl, height) {
    var R;
    R = {
      '~isa': 'TIDES/tidal-event',
      'source-line-nr': source_line_nr,
      'date': date,
      'is-dst': is_dst,
      'hl': hl,
      'height': height,
      'lunar-events': {
        'phase': null,
        'distance': null,
        'declination': null
      }
    };
    return R;
  };

  this.new_tidal_extrema_event = function(min_l_height, max_l_height, min_h_height, max_h_height) {
    var R;
    R = {
      '~isa': 'TIDES/tidal-extrema-event',
      'min-l-height': min_l_height,
      'max-l-height': max_l_height,
      'min-h-height': min_h_height,
      'max-h-height': max_h_height
    };
    return R;
  };


  /* TNG: unified 'lunar event' type */

  this.new_lunar_event = function(source_ref, category, marker, date, details) {
    var R;
    if (details == null) {
      details = null;
    }
    switch (category) {
      case 'phase':
        switch (marker) {
          case 0:
          case 1:
          case 2:
          case 3:
            null;
            break;
          default:
            throw new Error("illegal marker " + (rpr(marker)) + " for category " + (rpr(category)));
        }
        break;
      case 'distance':
        switch (marker) {
          case 'P':
          case 'A':
            null;
            break;
          default:
            throw new Error("illegal marker " + (rpr(marker)) + " for category " + (rpr(category)));
        }
        break;
      case 'declination':
        switch (marker) {
          case 'N':
          case 'S':
            null;
            break;
          default:
            throw new Error("illegal marker " + (rpr(marker)) + " for category " + (rpr(category)));
        }
        break;
      default:
        throw new Error("illegal category " + (rpr(category)));
    }
    R = {
      '~isa': 'TIDES/lunar-event',
      'category': category,
      'marker': marker,
      'source-ref': source_ref,
      'date': date,
      'details': details
    };
    return R;
  };

  this.walk_raw_fields = function(route, handler) {
    FS.lines_of(route, (function(_this) {
      return function(error, source_line, source_line_nr) {
        var fields, source_ref;
        if (error != null) {
          return handler(error);
        }
        if (source_line === null) {
          return handler(null, null, null);
        }
        source_ref = "" + route + "#" + source_line_nr;
        source_line = source_line.trim();
        if (source_line[0] === '#') {
          return;
        }
        if (source_line.length === 0) {
          return;
        }
        fields = source_line.split(/\s+/);
        return handler(null, fields, source_line, source_ref);
      };
    })(this));
    return null;
  };

  this.walk_lunar_distance_events = function(handler) {

    /* TAINT make configurable */
    var route;
    route = njs_path.join(__dirname, '../tidal-data/apogees-and-perigees.txt');
    return this.walk_raw_fields(route, (function(_this) {
      return function(error, fields, source_line, source_ref) {
        var date, date_txt, details, distance_km, distance_km_txt, field_count, marker, time_txt, tz;
        if (error != null) {
          return handler(error);
        }
        if (fields === null) {
          return handler(null, null);
        }
        if ((field_count = fields.length) !== 5) {
          throw new Error("expected 5 fields, got " + field_count + " on line #" + source_line_nr + " in file " + route);
        }
        date_txt = fields[0], time_txt = fields[1], tz = fields[2], distance_km_txt = fields[3], marker = fields[4];
        date = moment.tz("" + date_txt + " " + time_txt, tz);
        distance_km = parseInt(distance_km_txt, 10);

        /* TAINT make configurable */
        marker = marker === 'Apogee' ? 'A' : 'P';
        details = {
          'distance.km': distance_km
        };
        return handler(null, _this.new_lunar_event(source_ref, 'distance', marker, date, details));
      };
    })(this));
  };

  this.walk_lunar_declination_events = function(handler) {

    /* TAINT make configurable */
    var route;
    route = njs_path.join(__dirname, '../tidal-data/declination-maxima.txt');
    this.walk_raw_fields(route, (function(_this) {
      return function(error, fields, source_line, source_ref) {
        var date, date_txt, declination_deg, declination_txt, details, field_count, marker, time_txt, tz;
        if (error != null) {
          return handler(error);
        }
        if (fields === null) {
          return handler(null, null);
        }
        if ((field_count = fields.length) !== 4) {
          throw new Error("expected 4 fields, got " + field_count + " on line #" + source_line_nr + " in file " + route);
        }
        date_txt = fields[0], time_txt = fields[1], tz = fields[2], declination_txt = fields[3];
        date = moment.tz("" + date_txt + " " + time_txt, tz);
        marker = declination_txt[0];
        declination_deg = parseFloat(declination_txt.slice(1), 10);
        details = {
          'declination.deg': declination_deg
        };
        return handler(null, _this.new_lunar_event(source_ref, 'declination', marker, date, details));
      };
    })(this));
    return null;
  };

  this._walk_tidal_and_lunar_phase_events = function(route, handler) {
    var datetime_format, max_h_height, max_l_height, min_h_height, min_l_height, record_idx, timezone;
    record_idx = -1;
    datetime_format = this.options['data']['date']['raw-format'];
    timezone = this.options['data']['date']['timezone'];
    min_l_height = +Infinity;
    max_l_height = -Infinity;
    min_h_height = +Infinity;
    max_h_height = -Infinity;
    this.walk_raw_fields(route, (function(_this) {
      return function(error, fields, source_line, source_ref) {
        var columns, date_txt, field_count, height, height_txt, hl, is_dst, moon_date, moon_phase, moon_quarter, moon_time_txt, tide, tide_date, tide_time_txt;
        if (error != null) {
          return handler(error);
        }
        if (fields === null) {
          handler(null, _this.new_tidal_extrema_event(min_l_height, max_l_height, min_h_height, max_h_height));
          return handler(null, null);
        }
        columns = [];
        record_idx += 1;
        switch (field_count = fields.length) {
          case 5:
            date_txt = fields[0], tide_time_txt = fields[1], tide = fields[2], height_txt = fields[3];
            moon_phase = null;
            moon_quarter = null;
            moon_time_txt = null;
            break;
          case 7:
            date_txt = fields[0], moon_phase = fields[1], moon_time_txt = fields[2], tide_time_txt = fields[3], tide = fields[4], height_txt = fields[5];
            moon_quarter = _this.options['data']['moon']['quarter-by-phases'][moon_phase];
            break;
          default:
            return handler(new Error("unable to parse line " + source_ref + ":\n" + (rpr(source_line))));
        }
        height = parseInt(height_txt, 10);
        is_dst = /\+$/.test(tide_time_txt);
        switch (tide) {
          case 'LW':
            hl = 'l';
            min_l_height = Math.min(min_l_height, height);
            max_l_height = Math.max(max_l_height, height);
            break;
          case 'HW':
            hl = 'h';
            min_h_height = Math.min(min_h_height, height);
            max_h_height = Math.max(max_h_height, height);
            break;
          default:
            return handler(new Error("unable to parse tide entry on line " + source_line_nr + ": " + (rpr(tide))));
        }
        tide_date = moment.tz("" + date_txt + " " + tide_time_txt, datetime_format, timezone);

        /* TAINT use @options */
        tide_date.lang('nl');
        handler(null, _this.new_tidal_event(source_ref, tide_date, is_dst, hl, height));
        if (moon_phase == null) {
          return;
        }
        moon_date = moment.tz("" + date_txt + " " + moon_time_txt, datetime_format, timezone);

        /* TAINT use @options */
        moon_date.lang('nl');
        return handler(null, _this.new_lunar_event(source_ref, 'phase', moon_quarter, moon_date));
      };
    })(this));
    return null;
  };

  this.walk_tidal_and_lunar_phase_events = function(route, handler) {

    /* Same as `_walk_tidal_and_lunar_phase_events`, but delivers the tidal extrema first, so consumers know
    beforehand about tidal extrema to be expected.
     */
    var lunar_event_buffer, tasks, tidal_extrema_event, tidal_hl_event_buffer;
    tidal_extrema_event = null;
    tidal_hl_event_buffer = [];
    lunar_event_buffer = [];
    tasks = [];
    tasks.push((function(_this) {
      return function(done) {
        return _this._walk_tidal_and_lunar_phase_events(route, function(error, event) {
          var types;
          if (error != null) {
            return handler(error);
          }
          if (event === null) {
            return done(null);
          }
          switch (types = TYPES.type_of(event)) {
            case 'TIDES/tidal-extrema-event':
              return tidal_extrema_event = event;
            case 'TIDES/tidal-event':
              return tidal_hl_event_buffer.push(event);
            case 'TIDES/lunar-event':
              return lunar_event_buffer.push(event);
            default:
              return warn("skipped event of type " + (rpr(type)));
          }
        });
      };
    })(this));
    tasks.push((function(_this) {
      return function(done) {

        /* TAINT pass in route? use options? */
        return _this.walk_lunar_distance_events(function(error, event) {
          if (error != null) {
            return handler(error);
          }
          if (event === null) {
            return done(null);
          }
          return lunar_event_buffer.push(event);
        });
      };
    })(this));
    tasks.push((function(_this) {
      return function(done) {

        /* TAINT pass in route? use options? */
        return _this.walk_lunar_declination_events(function(error, event) {
          if (error != null) {
            return handler(error);
          }
          if (event === null) {
            return done(null);
          }
          return lunar_event_buffer.push(event);
        });
      };
    })(this));
    ASYNC.parallel(tasks, (function(_this) {
      return function(error) {
        var event, _i, _j, _len, _len1;
        if (error != null) {
          return handler(error);
        }
        handler(null, tidal_extrema_event);
        for (_i = 0, _len = tidal_hl_event_buffer.length; _i < _len; _i++) {
          event = tidal_hl_event_buffer[_i];
          handler(null, event);
        }
        for (_j = 0, _len1 = lunar_event_buffer.length; _j < _len1; _j++) {
          event = lunar_event_buffer[_j];
          handler(null, event);
        }
        return handler(null, null);
      };
    })(this));
    return null;
  };

  if (module.parent == null) {
    this._demo_align_tide_and_moon_events();
  }

}).call(this);
