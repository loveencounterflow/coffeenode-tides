// Generated by CoffeeScript 1.7.1
(function() {
  var FS, TRM, TYPES, alert, badge, debug, echo, eventually, help, info, log, moment, njs_fs, njs_path, rpr, warn, whisper;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  FS = require('coffeenode-fs');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/main';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  this.options = require('../options');

  eventually = process.nextTick;

  moment = require('moment-timezone');

  this.moon_quarter_by_phases = {
    'NM': 0,
    'EK': 1,
    'VM': 2,
    'LK': 3
  };

  this.new_tide_event = function(source_line_nr, date, is_dst, hl, height) {
    var R;
    R = {
      '~isa': 'TIDES/tide-event',
      'source-line-nr': source_line_nr,
      'date': date,
      'is-dst': is_dst,
      'hl': hl,
      'height': height,
      'moon': null
    };
    return R;
  };

  this.new_tidal_extrema_event = function(min_l_height, max_l_height, min_h_height, max_h_height) {
    var R;
    R = {
      '~isa': 'TIDES/tidal-extrema-event',
      'min-l-height': min_l_height,
      'max-l-height': max_l_height,
      'min-h-height': min_h_height,
      'max-h-height': max_h_height
    };
    return R;
  };

  this.new_moon_event = function(source_line_nr, date, is_dst, moon_quarter) {
    var R;
    R = {
      '~isa': 'TIDES/moon-event',
      'source-line-nr': source_line_nr,
      'date': date,
      'is-dst': is_dst,
      'quarter': moon_quarter
    };
    return R;
  };


  /* TNG: unified 'lunar event' type */

  this.new_lunar_event = function(source, category, marker, date, details) {
    var R;
    if (details == null) {
      details = null;
    }
    switch (category) {
      case 'tide':
        if (!((marker === 'h') || ('marker' === 'l'))) {
          throw new Error("illegal marker " + (rpr(marker)));
        }
        break;
      case 'distance':
        if (!((marker === 'P') || ('marker' === 'A'))) {
          throw new Error("illegal marker " + (rpr(marker)));
        }
        break;
      case 'declination':
        if (!((marker === 'N') || ('marker' === 'S'))) {
          throw new Error("illegal marker " + (rpr(marker)));
        }
        break;
      default:
        throw new Error("illegal category " + (rpr(category)));
    }
    R = {
      '~isa': 'TIDES/moon-event',
      'category': category,
      'marker': marker,
      'source': source,
      'date': date,
      'details': details
    };
    return R;
  };

  this.walk_raw_fields = function(route, handler) {
    FS.lines_of(route, (function(_this) {
      return function(error, source_line, source_line_nr) {
        var fields;
        if (error != null) {
          return handler(error);
        }
        if (source_line === null) {
          return handler(null, null);
        }
        source_line = source_line.trim();
        if (source_line[0] === '#') {
          return;
        }
        fields = source_line.split(/\s+/);
        return handler(null, fields, source_line, source_line_nr);
      };
    })(this));
    return null;
  };

  this.walk_lunar_distance_events = function(route, handler) {};

  this.walk_lunar_declination_events = function(route, handler) {};

  this.walk_tide_and_moon_events = function(route, handler) {
    var datetime_format, max_h_height, max_l_height, min_h_height, min_l_height, record_idx, timezone;
    record_idx = -1;
    datetime_format = this.options['data']['date']['raw-format'];
    timezone = this.options['data']['date']['timezone'];
    min_l_height = +Infinity;
    max_l_height = -Infinity;
    min_h_height = +Infinity;
    max_h_height = -Infinity;
    this.walk_raw_fields(route, (function(_this) {
      return function(error, fields, source_line, source_line_nr) {
        var columns, date_txt, field_count, height, height_txt, hl, is_dst, moon_date, moon_phase, moon_quarter, moon_time_txt, tide, tide_date, tide_time_txt;
        if (error != null) {
          return handler(error);
        }
        if (fields === null) {
          handler(null, _this.new_tidal_extrema_event(min_l_height, max_l_height, min_h_height, max_h_height));
          return handler(null, null);
        }
        columns = [];
        record_idx += 1;
        switch (field_count = fields.length) {
          case 5:
            date_txt = fields[0], tide_time_txt = fields[1], tide = fields[2], height_txt = fields[3];
            moon_phase = null;
            moon_quarter = null;
            moon_time_txt = null;
            break;
          case 7:
            date_txt = fields[0], moon_phase = fields[1], moon_time_txt = fields[2], tide_time_txt = fields[3], tide = fields[4], height_txt = fields[5];
            moon_quarter = _this.options['data']['moon']['quarter-by-phases'][moon_phase];
            break;
          default:
            return handler(new Error("unable to parse line " + source_line_nr + ": " + (rpr(source_line))));
        }
        height = parseInt(height_txt, 10);
        is_dst = /\+$/.test(tide_time_txt);
        switch (tide) {
          case 'LW':
            hl = 'l';
            min_l_height = Math.min(min_l_height, height);
            max_l_height = Math.max(max_l_height, height);
            break;
          case 'HW':
            hl = 'h';
            min_h_height = Math.min(min_h_height, height);
            max_h_height = Math.max(max_h_height, height);
            break;
          default:
            return handler(new Error("unable to parse tide entry on line " + source_line_nr + ": " + (rpr(tide))));
        }
        tide_date = moment.tz("" + date_txt + " " + tide_time_txt, datetime_format, timezone);

        /* TAINT use @options */
        tide_date.lang('nl');
        handler(null, _this.new_tide_event(source_line_nr, tide_date, is_dst, hl, height));
        if (moon_phase == null) {
          return;
        }
        moon_date = moment.tz("" + date_txt + " " + moon_time_txt, datetime_format, timezone);

        /* TAINT use @options */
        moon_date.lang('nl');
        return handler(null, _this.new_moon_event(source_line_nr, moon_date, is_dst, moon_quarter));
      };
    })(this));
    return null;
  };

  this.walk_events_extrema_first = function(route, handler) {
    var buffer;
    buffer = [];
    this.walk_tide_and_moon_events(route, (function(_this) {
      return function(error, event) {
        var _i, _len;
        if (error != null) {
          return handler(error);
        }
        if (event === null) {
          for (_i = 0, _len = buffer.length; _i < _len; _i++) {
            event = buffer[_i];
            handler(null, event);
          }
          return handler(null, null);
        }
        if (TYPES.isa(event, 'TIDES/tidal-extrema-event')) {
          return handler(null, event);
        }
        return buffer.push(event);
      };
    })(this));
    return null;
  };

  this.walk = function(route, handler) {
    var clear_tide_buffer, find_closest_tide_for_moon_event, moon_buffer, tide_buffer, tide_buffer_max_length, waiting_for_moon;
    tide_buffer = [];
    tide_buffer_max_length = 6;
    moon_buffer = [];
    waiting_for_moon = false;
    find_closest_tide_for_moon_event = (function(_this) {
      return function() {
        var dt, dt_min, moon_date, moon_event, target_event, tide_date, tide_event, _i, _len;
        if (moon_buffer.length === 0) {
          return;
        }
        if (moon_buffer.length > 1) {
          return handler(new Error("too many moon events in buffer (" + moon_buffer.length + ")"));
        }
        moon_event = moon_buffer.shift();
        moon_date = moon_event['date'];
        dt_min = Infinity;
        for (_i = 0, _len = tide_buffer.length; _i < _len; _i++) {
          tide_event = tide_buffer[_i];
          tide_date = tide_event['date'];
          dt = Math.abs((moment.duration(tide_date.diff(moon_date))).asHours());
          if (dt > dt_min) {
            continue;
          }
          dt_min = dt;
          target_event = tide_event;
        }
        return target_event['moon'] = moon_event;
      };
    })(this);
    clear_tide_buffer = (function(_this) {
      return function(max_length) {
        var _results;
        _results = [];
        while (tide_buffer.length > max_length) {
          _results.push(handler(null, tide_buffer.shift()));
        }
        return _results;
      };
    })(this);
    return this.walk_events_extrema_first(route, (function(_this) {
      return function(error, event) {
        var type;
        if (error != null) {
          return handler(error);
        }

        /* Release remaining buffer contents and finish: */

        /* TAINT must look for remaining moon entries in buffer */
        if (event === null) {
          find_closest_tide_for_moon_event();
          clear_tide_buffer(0);
          if (moon_buffer.length !== 0) {
            return handler(new Error("found " + moon_buffer.length + " unprocessed moon events"));
          }
          return handler(null, null);
        }
        switch (type = event['~isa']) {
          case 'TIDES/tide-event':
            tide_buffer.push(event);
            break;
          case 'TIDES/moon-event':
            moon_buffer.push(event);
            waiting_for_moon = true;
            break;
          case 'TIDES/tidal-extrema-event':
            _this.options['data']['tides']['min-l-height'] = event['min-l-height'];
            _this.options['data']['tides']['max-l-height'] = event['max-l-height'];
            _this.options['data']['tides']['min-h-height'] = event['min-h-height'];
            _this.options['data']['tides']['max-h-height'] = event['max-h-height'];
            break;
          default:
            return handler(new Error("unknown event type " + (rpr(type))));
        }
        if (waiting_for_moon) {
          if (tide_buffer.length >= tide_buffer_max_length) {
            find_closest_tide_for_moon_event();
            waiting_for_moon = false;
            return clear_tide_buffer(0);
          }
        } else {
          return clear_tide_buffer(2);
        }
      };
    })(this));
  };

  this._demo_walk_tide_and_moon_events = function() {
    var TIDES, route;
    TIDES = this;
    route = njs_path.join(__dirname, '../tidal-data/Vlieland-haven.txt');
    TIDES.walk_tide_and_moon_events(route, (function(_this) {
      return function(error, event) {
        var date, date_txt, height, hl, quarter, symbol;
        if (error != null) {
          throw error;
        }
        if (event === null) {
          return;
        }
        date = event['date'];
        date_txt = date.format('dddd, D. MMMM YYYY HH:mm');
        if (TYPES.isa(event, 'TIDES/moon-event')) {
          quarter = event['quarter'];
          symbol = TIDES.options['data']['moon']['unicode'][quarter];
          return log(TRM.lime(date_txt, quarter, symbol));
        } else {
          hl = event['hl'];
          height = event['height'];
          return log(TRM.gold(date_txt, hl, height));
        }
      };
    })(this));
    return null;
  };

  this._demo_walk = function() {
    var TIDES, last_moon_idx, route, tide_idx, tide_moon_counts, _;
    _ = require('lodash');
    TIDES = this;
    route = njs_path.join(__dirname, '../tidal-data/Vlieland-haven.txt');
    tide_moon_counts = [];
    tide_idx = 0;
    last_moon_idx = null;
    TIDES.walk(route, (function(_this) {
      return function(error, event) {
        var date, date_txt, event_txt, height, hl, moon_event, quarter, symbol;
        if (error != null) {
          throw error;
        }
        if (event === null) {
          info(_.countBy(tide_moon_counts));
          return;
        }
        tide_idx += 1;
        date = event['date'];
        date_txt = date.format('ddd, DD. MMM YYYY HH:mm');
        hl = event['hl'];
        height = event['height'];
        event_txt = TRM.gold(date_txt, hl, height);
        if ((moon_event = event['moon']) != null) {
          if (moon_event['quarter'] === 0) {
            if (last_moon_idx != null) {
              tide_moon_counts.push(tide_idx - last_moon_idx);
            }
            last_moon_idx = tide_idx;
          }
          date = moon_event['date'];
          date_txt = date.format('ddd, D. MMM YYYY HH:mm');
          quarter = moon_event['quarter'];
          symbol = TIDES.options['data']['moon']['unicode'][quarter];
          event_txt += ' ' + TRM.lime(date_txt, quarter, symbol);
        }
        return log(event_txt);
      };
    })(this));
    return null;
  };

  if (module.parent == null) {
    this._demo_walk();
  }

}).call(this);
