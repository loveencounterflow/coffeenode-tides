// Generated by CoffeeScript 1.7.1
(function() {
  var ASYNC, FI, FS, TRM, TYPES, alert, bSearch, badge, debug, echo, eventually, help, info, log, moment, njs_fs, njs_path, route, rpr, warn, whisper;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  FS = require('coffeenode-fs');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/main';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  bSearch = require('coffeenode-bsearch');

  this.options = require('../options');

  eventually = process.nextTick;

  moment = require('moment-timezone');

  ASYNC = require('async');

  FI = require('coffeenode-fillin');

  this.new_tidal_event = function(source_line_nr, date, is_dst, hl, height) {
    var R;
    R = {
      '~isa': 'TIDES/tidal-event',
      'source-line-nr': source_line_nr,
      'date': date,
      'is-dst': is_dst,
      'hl': hl,
      'height': height,
      'lunar-events': {
        'phase': null,
        'distance': null,
        'declination': null
      }
    };
    return R;
  };

  this.new_tidal_extrema_event = function(min_l_height, max_l_height, min_h_height, max_h_height) {
    var R;
    R = {
      '~isa': 'TIDES/tidal-extrema-event',
      'min-l-height': min_l_height,
      'max-l-height': max_l_height,
      'min-h-height': min_h_height,
      'max-h-height': max_h_height
    };
    return R;
  };

  this.new_lunar_declination_extremum_event = function(min_declination_deg, max_declination_deg) {
    var R;
    R = {
      '~isa': 'TIDES/lunar-declination-extremum-event',
      'min-declination.deg': min_declination_deg,
      'max-declination.deg': max_declination_deg
    };
    return R;
  };

  this.new_lunar_distance_extremum_event = function(min_distance_km, max_distance_km) {
    var R;
    R = {
      '~isa': 'TIDES/lunar-distance-extremum-event',
      'min-distance.km': min_distance_km,
      'max-distance.km': max_distance_km
    };
    return R;
  };

  this.new_lunar_event = function(source_ref, category, marker, date, details) {
    var R;
    if (details == null) {
      details = null;
    }
    switch (category) {
      case 'phase':
        switch (marker) {
          case 0:
          case 1:
          case 2:
          case 3:
            null;
            break;
          default:
            throw new Error("illegal marker " + (rpr(marker)) + " for category " + (rpr(category)));
        }
        break;
      case 'distance':
        switch (marker) {
          case 'P':
          case 'A':
            null;
            break;
          default:
            throw new Error("illegal marker " + (rpr(marker)) + " for category " + (rpr(category)));
        }
        break;
      case 'declination':
        switch (marker) {
          case 'N':
          case 'S':
            null;
            break;
          default:
            throw new Error("illegal marker " + (rpr(marker)) + " for category " + (rpr(category)));
        }
        break;
      default:
        throw new Error("illegal category " + (rpr(category)));
    }
    R = {
      '~isa': 'TIDES/lunar-event',
      'category': category,
      'marker': marker,
      'source-ref': source_ref,
      'date': date,
      'details': details
    };
    return R;
  };

  this.walk_raw_fields = function(route, handler) {
    FS.lines_of(route, (function(_this) {
      return function(error, source_line, source_line_nr) {
        var fields, source_ref;
        if (error != null) {
          return handler(error);
        }
        if (source_line === null) {
          return handler(null, null, null);
        }
        source_ref = "" + route + "#" + source_line_nr;
        source_line = source_line.trim();
        if (source_line[0] === '#') {
          return;
        }
        if (source_line.length === 0) {
          return;
        }
        fields = source_line.split(/\s+/);
        return handler(null, fields, source_line, source_ref);
      };
    })(this));
    return null;
  };

  this.walk_lunar_distance_events = function(handler) {

    /* TAINT make configurable */
    var max_distance_km, min_distance_km, route;
    route = njs_path.join(__dirname, '../tidal-data/apogees-and-perigees.txt');
    min_distance_km = +Infinity;
    max_distance_km = -Infinity;
    return this.walk_raw_fields(route, (function(_this) {
      return function(error, fields, source_line, source_ref) {
        var R, date, date_txt, details, distance_km, distance_km_txt, field_count, marker, time_txt, tz;
        if (error != null) {
          return handler(error);
        }
        if (fields === null) {
          handler(null, _this.new_lunar_distance_extremum_event(min_distance_km, max_distance_km));
          return handler(null, null);
        }
        if ((field_count = fields.length) !== 5) {
          throw new Error("expected 5 fields, got " + field_count + " on line #" + source_line_nr + " in file " + route);
        }
        date_txt = fields[0], time_txt = fields[1], tz = fields[2], distance_km_txt = fields[3], marker = fields[4];
        date = moment.tz("" + date_txt + " " + time_txt, tz);
        distance_km = parseInt(distance_km_txt, 10);

        /* TAINT make configurable */
        marker = marker === 'Apogee' ? 'A' : 'P';
        details = {
          'distance.km': distance_km
        };
        min_distance_km = Math.min(min_distance_km, distance_km);
        max_distance_km = Math.max(max_distance_km, distance_km);
        return handler(null, R = _this.new_lunar_event(source_ref, 'distance', marker, date, details));
      };
    })(this));
  };

  this.walk_lunar_declination_events = function(handler) {

    /* TAINT make configurable */
    var max_declination_deg, min_declination_deg, route;
    route = njs_path.join(__dirname, '../tidal-data/declination-maxima.txt');
    min_declination_deg = +Infinity;
    max_declination_deg = -Infinity;
    this.walk_raw_fields(route, (function(_this) {
      return function(error, fields, source_line, source_ref) {
        var date, date_txt, declination_deg, declination_txt, details, field_count, marker, time_txt, tz;
        if (error != null) {
          return handler(error);
        }
        if (fields === null) {
          handler(null, _this.new_lunar_declination_extremum_event(min_declination_deg, max_declination_deg));
          return handler(null, null);
        }
        if ((field_count = fields.length) !== 4) {
          throw new Error("expected 4 fields, got " + field_count + " on line #" + source_line_nr + " in file " + route);
        }
        date_txt = fields[0], time_txt = fields[1], tz = fields[2], declination_txt = fields[3];
        date = moment.tz("" + date_txt + " " + time_txt, tz);
        marker = declination_txt[0];
        declination_deg = parseFloat(declination_txt.slice(1), 10);
        min_declination_deg = Math.min(min_declination_deg, declination_deg);
        max_declination_deg = Math.max(max_declination_deg, declination_deg);
        details = {
          'declination.deg': declination_deg
        };
        return handler(null, _this.new_lunar_event(source_ref, 'declination', marker, date, details));
      };
    })(this));
    return null;
  };

  this._walk_tidal_and_lunar_phase_events = function(route, handler) {
    var datetime_format, max_h_height, max_l_height, min_h_height, min_l_height, record_idx, timezone;
    record_idx = -1;
    datetime_format = this.options['data']['date']['raw-format'];
    timezone = this.options['data']['date']['timezone'];
    min_l_height = +Infinity;
    max_l_height = -Infinity;
    min_h_height = +Infinity;
    max_h_height = -Infinity;
    this.walk_raw_fields(route, (function(_this) {
      return function(error, fields, source_line, source_ref) {
        var columns, date_txt, field_count, height, height_txt, hl, is_dst, moon_date, moon_phase, moon_quarter, moon_time_txt, tide, tide_date, tide_time_txt;
        if (error != null) {
          return handler(error);
        }
        if (fields === null) {
          handler(null, _this.new_tidal_extrema_event(min_l_height, max_l_height, min_h_height, max_h_height));
          FI.set(_this.options, '/data/extrema/tides/min-l-height', min_l_height);
          FI.set(_this.options, '/data/extrema/tides/max-l-height', max_l_height);
          FI.set(_this.options, '/data/extrema/tides/min-h-height', min_h_height);
          FI.set(_this.options, '/data/extrema/tides/max-h-height', max_h_height);
          return handler(null, null);
        }
        columns = [];
        record_idx += 1;
        switch (field_count = fields.length) {
          case 5:
            date_txt = fields[0], tide_time_txt = fields[1], tide = fields[2], height_txt = fields[3];
            moon_phase = null;
            moon_quarter = null;
            moon_time_txt = null;
            break;
          case 7:
            date_txt = fields[0], moon_phase = fields[1], moon_time_txt = fields[2], tide_time_txt = fields[3], tide = fields[4], height_txt = fields[5];
            moon_quarter = _this.options['data']['moon']['quarter-by-phases'][moon_phase];
            break;
          default:
            return handler(new Error("unable to parse line " + source_ref + ":\n" + (rpr(source_line))));
        }
        height = parseInt(height_txt, 10);
        is_dst = /\+$/.test(tide_time_txt);
        switch (tide) {
          case 'LW':
            hl = 'l';
            min_l_height = Math.min(min_l_height, height);
            max_l_height = Math.max(max_l_height, height);
            break;
          case 'HW':
            hl = 'h';
            min_h_height = Math.min(min_h_height, height);
            max_h_height = Math.max(max_h_height, height);
            break;
          default:
            return handler(new Error("unable to parse tide entry on line " + source_line_nr + ": " + (rpr(tide))));
        }
        tide_date = moment.tz("" + date_txt + " " + tide_time_txt, datetime_format, timezone);

        /* TAINT use @options */
        tide_date.lang('nl');
        handler(null, _this.new_tidal_event(source_ref, tide_date, is_dst, hl, height));
        if (moon_phase == null) {
          return;
        }
        moon_date = moment.tz("" + date_txt + " " + moon_time_txt, datetime_format, timezone);

        /* TAINT use @options */
        moon_date.lang('nl');
        return handler(null, _this.new_lunar_event(source_ref, 'phase', moon_quarter, moon_date));
      };
    })(this));
    return null;
  };

  this.read_tidal_and_lunar_event_batches = function(route, handler) {

    /* As the name says, the method will read tidal and lunar events and return a list with three batches
    (i.e. lists) of events.
    
    The batches list will be ordered as follows:
    * first comes a list with a single `TIDES/tidal-extrema-event`, announcing the lows and highs for the
      place and time under consideration;
    * next come all the tidal lows and heights;
    * finally, the lunar events—phases as well as declination and distance extrema—are sent.
    
    Note that **(1)** each event category is sorted **as they appear in the datasources**, so in case they
    should *not* appear in ascending order, expect weird results when trying to align events using binary
    search; **(2)** lunar events are sorted only **within**, not **across** event categories, so it may happen
    that a lunar declination event for July comes earlier than, say, a lunar phase event for January.
     */
    var extrema_event_batch, lunar_event_batch, tasks, tidal_hl_event_batch;
    extrema_event_batch = {
      'tidal': null,
      'declination': null,
      'distance': null
    };
    tidal_hl_event_batch = [];
    lunar_event_batch = [];
    tasks = [];
    tasks.push((function(_this) {
      return function(done) {
        return _this._walk_tidal_and_lunar_phase_events(route, function(error, event) {
          var types;
          if (error != null) {
            return handler(error);
          }
          if (event === null) {
            return done(null);
          }
          switch (types = TYPES.type_of(event)) {
            case 'TIDES/tidal-extrema-event':
              return extrema_event_batch['tidal'] = event;
            case 'TIDES/tidal-event':
              return tidal_hl_event_batch.push(event);
            case 'TIDES/lunar-event':
              return lunar_event_batch.push(event);
            default:
              return warn("skipped event of type " + (rpr(type)));
          }
        });
      };
    })(this));
    tasks.push((function(_this) {
      return function(done) {

        /* TAINT pass in route? use options? */
        return _this.walk_lunar_distance_events(function(error, event) {
          if (error != null) {
            return handler(error);
          }
          if (event === null) {
            return done(null);
          }
          if (event['~isa'] === 'TIDES/lunar-distance-extremum-event') {
            return extrema_event_batch['distance'] = event;
          } else {
            return lunar_event_batch.push(event);
          }
        });
      };
    })(this));
    tasks.push((function(_this) {
      return function(done) {

        /* TAINT pass in route? use options? */
        return _this.walk_lunar_declination_events(function(error, event) {
          if (error != null) {
            return handler(error);
          }
          if (event === null) {
            return done(null);
          }
          if (event['~isa'] === 'TIDES/lunar-declination-extremum-event') {
            return extrema_event_batch['declination'] = event;
          } else {
            return lunar_event_batch.push(event);
          }
        });
      };
    })(this));
    ASYNC.parallel(tasks, (function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return handler(null, [extrema_event_batch, tidal_hl_event_batch, lunar_event_batch]);
      };
    })(this));
    return null;
  };

  this._align_lunar_with_tidal_event = function(tidal_events, lunar_event) {
    var category, get_compare, idx, lunar_date, tidal_event;
    get_compare = (function(_this) {
      return function(probe_event) {
        return function(data_event) {
          return probe_event['date'] - data_event['date'];
        };
      };
    })(this);
    category = lunar_event['category'];
    lunar_date = lunar_event['date'];
    idx = bSearch.closest(tidal_events, get_compare(lunar_event));
    if (idx == null) {
      throw new Error("should never happen: uanble to align events");
    }
    tidal_event = tidal_events[idx];
    tidal_event['lunar-events'][category] = lunar_event;
    return tidal_event;
  };

  this.read_aligned_events = function(route, handler) {
    this.read_tidal_and_lunar_event_batches(route, (function(_this) {
      return function(error, event_batches) {
        var event, extrema_event_batch, lunar_event_batch, tidal_hl_event_batch, _i, _len;
        if (error != null) {
          throw error;
        }
        extrema_event_batch = event_batches[0], tidal_hl_event_batch = event_batches[1], lunar_event_batch = event_batches[2];
        for (_i = 0, _len = lunar_event_batch.length; _i < _len; _i++) {
          event = lunar_event_batch[_i];
          _this._align_lunar_with_tidal_event(tidal_hl_event_batch, event);
        }
        return handler(null, [extrema_event_batch, tidal_hl_event_batch]);
      };
    })(this));
    return null;
  };

  if (module.parent == null) {
    route = njs_path.join(__dirname, '../tidal-data/Vlieland-haven.txt');
    this.read_aligned_events(route, function(error, ignored) {
      if (error != null) {
        throw error;
      }
      return debug('ok');
    });
  }

}).call(this);
