// Generated by CoffeeScript 1.7.1
(function() {
  var FS, TIDES, TRM, TYPES, XDate, alert, badge, debug, echo, eventually, help, info, log, njs_fs, njs_path, route, rpr, warn, whisper;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  FS = require('coffeenode-fs');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/main';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  eventually = process.nextTick;

  XDate = require('xdate');

  this.moon_quarter_by_phases = {
    'NM': 0,
    'EK': 1,
    'VM': 2,
    'LK': 3
  };

  this.new_tidal_record = function(source_line_nr, moon_quarter, date, time, hl, height) {
    var R;
    R = {
      '~isa': 'GEZEITEN/tidal-record',
      'source-line-nr': source_line_nr,
      'moon-quarter': moon_quarter,
      'date': date,
      'time': time,
      'hl': hl,
      'height': height
    };
    return R;
  };

  this.new_table_row = function(source_line_nr, date) {
    var R;
    R = {
      '~isa': 'GEZEITEN/tidal-table-line',
      'source-line-nr': source_line_nr,
      'date': date,
      'weekday-idx': null,
      'moon-quarter': null,
      'day-change': false,
      'hi-water-time': null,
      'lo-water-time': null,
      'hi-water-height': null,
      'lo-water-height': null
    };
    return R;
  };

  this.walk_tidal_raw_fields = function(route, handler) {
    FS.lines_of(route, (function(_this) {
      return function(error, source_line, source_line_nr) {
        var fields;
        if (error != null) {
          return handler(error);
        }
        if (source_line === null) {
          return handler(null, null);
        }
        source_line = source_line.trim();
        if (source_line[0] === '#') {
          return;
        }
        fields = source_line.split(/\s+/);
        return handler(null, fields, source_line, source_line_nr);
      };
    })(this));
    return null;
  };

  this.walk_tidal_records = function(route, handler) {
    this.walk_tidal_raw_fields(route, (function(_this) {
      return function(error, fields, source_line, source_line_nr) {
        var Z, columns, date, date_txt, day_txt, field_count, height, height_txt, hl, hour_txt, ignored, minute_txt, month_txt, moon_phase, moon_quarter, tide, time, time_txt, year_txt, _ref, _ref1;
        if (error != null) {
          return handler(error);
        }
        if (fields === null) {
          return handler(null, null);
        }
        columns = [];
        switch (field_count = fields.length) {
          case 5:
            date_txt = fields[0], time_txt = fields[1], tide = fields[2], height_txt = fields[3];
            moon_phase = null;
            break;
          case 7:
            date_txt = fields[0], moon_phase = fields[1], ignored = fields[2], time_txt = fields[3], tide = fields[4], height_txt = fields[5];
            break;
          default:
            return handler(new Error("unable to parse line " + source_line_nr + ": " + (rpr(source_line))));
        }
        _ref = date_txt.split('/'), day_txt = _ref[0], month_txt = _ref[1], year_txt = _ref[2];
        _ref1 = time_txt.split(':'), hour_txt = _ref1[0], minute_txt = _ref1[1];
        hour_txt = hour_txt.replace(/^0/, ' ');
        day_txt = day_txt.replace(/^0/, ' ');
        month_txt = month_txt.replace(/^0/, ' ');
        moon_quarter = moon_phase != null ? _this.moon_quarter_by_phases[moon_phase] : null;
        height = parseInt(height_txt, 10);
        date = [year_txt, month_txt, day_txt];
        time = [hour_txt, minute_txt];
        switch (tide) {
          case 'LW':
            hl = 'l';
            break;
          case 'HW':
            hl = 'h';
            break;
          default:
            return handler(new Error("unable to parse tide entry on line " + source_line_nr + ": " + (rpr(tide))));
        }
        Z = _this.new_tidal_record(source_line_nr, moon_quarter, date, time, hl, height);
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this.walk_table_rows = function(route, handler) {
    var Z, last_day, last_month, last_year;
    Z = null;
    last_day = null;
    last_month = null;
    last_year = null;
    this.walk_tidal_records(route, (function(_this) {
      return function(error, tidal_record) {
        var hl, moon_quarter, source_line_nr, this_date, this_day, this_month, this_year, xdate;
        if (error != null) {
          throw error;
        }
        if (tidal_record === null) {
          if (Z != null) {
            handler(null, Z);
          }
          return handler(null, null);
        }
        if (tidal_record['date'][1] !== ' 1') {
          return null;
        }
        source_line_nr = tidal_record['source-line-nr'];
        hl = tidal_record['hl'];
        this_date = tidal_record['date'];
        this_year = this_date[0], this_month = this_date[1], this_day = this_date[2];
        if (Z == null) {
          Z = _this.new_table_row(source_line_nr, this_date);
        }
        if (hl === 'h') {
          Z['hi-water-time'] = tidal_record['time'];
          Z['hi-water-height'] = tidal_record['height'];
        } else {
          Z['lo-water-time'] = tidal_record['time'];
          Z['lo-water-height'] = tidal_record['height'];
        }

        /* TAINT this procedure will likely work if the place of processing is in the same timezone as the
        place where the given data refers to; in the more general case, however, JavaScript as running in NodeJS
        will probably understand dates in terms of the current local at the place of processing and cause
        subtle or not so subtle mismatches between times and dates as intended and as processed.
        
        Also, under the assumptions that each day appears at least once in the data and all days are called up
        sequentially, it suffices to calculate the weekday for the first day called and the cycle through
        the list of weekday names.
         */
        if (Z['weekday-idx'] == null) {
          xdate = new XDate(this_year, this_month, this_day);
          Z['weekday-idx'] = (xdate.getDay() + 6) % 7;
        }
        if (this_day !== last_day) {
          last_day = this_day;
          if (hl === 'l') {
            Z['day-change'] = true;
          }
        }
        if ((moon_quarter = tidal_record['moon-quarter']) != null) {
          Z['moon-quarter'] = moon_quarter;
        }
        if (Z['lo-water-time'] != null) {
          handler(null, Z);
          return Z = null;
        }
      };
    })(this));
    return null;
  };

  if (module.parent == null) {
    TIDES = this;
    route = njs_path.join(__dirname, '../tidal-data/Vlieland-haven.txt');
    TIDES.walk_table_rows(route, function(error, table_row) {
      if (error != null) {
        throw error;
      }
      return info(TRM.rainbow(table_row));
    });
  }

}).call(this);
