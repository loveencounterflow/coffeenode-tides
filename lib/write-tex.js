// Generated by CoffeeScript 1.7.1
(function() {
  var BAP, FI, TEX, TEXT, TIDES, TRM, TYPES, alert, badge, debug, echo, esc, hbox, help, info, leading, leavevmode, log, multicolumn, newline, njs_fs, njs_path, paCenter, paCenterGauge, paLeft, paLeftGauge, paRight, paRightGauge, postscript, preamble, read, rpr, sine, thinspace, warn, whisper,
    __modulo = function(a, b) { return (a % b + +b) % b; };

  njs_fs = require('fs');

  njs_path = require('path');

  BAP = require('coffeenode-bitsnpieces');

  TYPES = require('coffeenode-types');

  TEXT = require('coffeenode-text');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/write-tex';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  TEX = require('jizura-xelatex');

  TIDES = require('./main');

  FI = require('coffeenode-fillin');

  sine = require('./sine');

  this._draw_curves_with_gm = require('./draw-curves-with-gm');

  read = function(route) {
    return njs_fs.readFileSync(njs_path.join(__dirname, route), {
      encoding: 'utf-8'
    });
  };

  preamble = read('../tex-inputs/preamble.tex');

  postscript = read('../tex-inputs/postscript.tex');

  leavevmode = TEX.make_command('leavevmode');

  hbox = TEX.make_command('hbox');

  leading = TEX.make_command('leading');

  multicolumn = TEX.make_multicommand('multicolumn', 3);

  paLeft = TEX.make_multicommand('paLeft', 3);

  paCenter = TEX.make_multicommand('paCenter', 3);

  paRight = TEX.make_multicommand('paRight', 3);

  paLeftGauge = TEX.make_multicommand('paLeftGauge', 3);

  paCenterGauge = TEX.make_multicommand('paCenterGauge', 3);

  paRightGauge = TEX.make_multicommand('paRightGauge', 3);

  newline = TEX.raw('\n');

  esc = TEX._escape.bind(TEX);

  thinspace = '\u2009';

  this.format_month_name = function(page_nr, date) {

    /* TAINT make formats configurable */
    var align_x, align_y, alignment, chapter_mark, content, is_even_page, month_name, pa_command, position_x, position_y;
    month_name = date.format('MMMM');
    month_name = month_name[0].toUpperCase() + month_name.slice(1);

    /* TAINT inefficient to retrieve each time; options should use cache */
    is_even_page = __modulo(page_nr, 2) === 0;
    if (is_even_page) {
      align_x = FI.get(TIDES.options, '/values/layout/month/even/align/x');
      align_y = FI.get(TIDES.options, '/values/layout/month/even/align/y');
      position_x = (FI.get(TIDES.options, '/values/layout/month/even/position/x')) + 'mm';
      position_y = (FI.get(TIDES.options, '/values/layout/month/even/position/y')) + 'mm';
    } else {
      align_x = FI.get(TIDES.options, '/values/layout/month/odd/align/x');
      align_y = FI.get(TIDES.options, '/values/layout/month/odd/align/y');
      position_x = (FI.get(TIDES.options, '/values/layout/month/odd/position/x')) + 'mm';
      position_y = (FI.get(TIDES.options, '/values/layout/month/odd/position/y')) + 'mm';
    }
    switch (alignment = align_x) {
      case 'left':
        pa_command = paLeftGauge;
        break;
      case 'center':
        pa_command = paCenterGauge;
        break;
      case 'right':
        pa_command = paRightGauge;
        break;
      default:
        throw new Error("unknown alignment " + (rpr(alignment)));
    }
    content = TEX.new_group([TEX.new_loner('scFont'), TEX.new_loner('large'), TEX.new_command('color', 'DarkRed'), month_name]);
    chapter_mark = TEX.new_multicommand('markboth', 2, [month_name, month_name]);
    return [pa_command([position_x, position_y, content]), chapter_mark];
  };

  this.draw_curves = function(page_nr, dots, handler) {
    return this._draw_curves_with_gm(page_nr, dots, handler);
  };

  this._y_position_from_row_idx = function(row_idx, module, unit) {
    var value;
    if (unit == null) {
      unit = 'mm';
    }

    /* TAINT make configurable */

    /* TAINT use proper units datatype */
    value = (row_idx + 1) * module;
    value = value.toFixed(2);
    return "" + value + unit;
  };

  this._get_moon_phase = function(lunar_events) {
    var event, moon_quarter, moon_symbol;
    if ((event = lunar_events['phase']) == null) {
      return [null, null];
    }
    moon_quarter = event['marker'];
    moon_symbol = FI.get(TIDES.options, "/values/moon/quarters/" + moon_quarter);
    return [moon_quarter, moon_symbol];
  };

  this._get_moon_distance = function(lunar_events) {
    var ap, ap_symbol, distance_ed, distance_km, event;
    if ((event = lunar_events['distance']) == null) {
      return [null, null, null];
    }
    ap = event['marker'];
    ap_symbol = FI.get(TIDES.options, "/values/moon/distance/" + ap);
    distance_km = event['details']['distance.km'];
    distance_ed = distance_km / 12742;
    return [ap, ap_symbol, distance_ed];
  };

  this._get_moon_declination = function(lunar_events) {
    var declination_deg, event, sn, sn_symbol;
    if ((event = lunar_events['declination']) == null) {
      return [null, null, null];
    }
    sn = event['marker'];
    sn_symbol = FI.get(TIDES.options, "/values/moon/declination/" + sn);
    declination_deg = event['details']['declination.deg'];
    return [sn, sn_symbol, declination_deg];
  };

  this._add_dots_day_entry = function(dots, row_idx, day, hl) {
    dots['days'].push({
      row_idx: row_idx,
      day: day,
      hl: hl
    });
    return null;
  };

  this._new_dots = function() {
    var R;
    R = [];
    R['days'] = [];
    return R;
  };

  this.main = function() {

    /* TAINT must parametrize data source */
    var dots, last_day, last_month, last_year, moon_quarter, page_nr, route, row_idx, rows, wrote_header;
    route = njs_path.join(__dirname, '../tidal-data/Vlieland-haven.txt');
    rows = TEX.new_container([]);
    row_idx = -1;
    dots = this._new_dots();
    page_nr = 0;
    last_day = null;
    last_month = null;
    last_year = null;
    moon_quarter = null;
    wrote_header = false;
    echo(preamble);
    echo("\\renewcommand{\\placename}{Schiermonnikoog}");
    echo("\\renewcommand{\\placename}{Vlieland (Haven)}");
    TIDES.read_aligned_events(route, (function(_this) {
      return function(error, event_batches) {
        var ap, ap_symbol, chapter_mark, color, date, day_txt, declination_deg, distance_ed, dst, extrema_event_batch, height, hl, line_count, lunar_events, module, month_txt, moon_symbol, sn, sn_symbol, symbols, textheight, this_day, this_month, this_month_tex, tidal_event, tidal_hl_event_batch, time_txt, unit, weekday_txt, x_position, y_position, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
        if (error != null) {
          throw error;
        }
        extrema_event_batch = event_batches[0], tidal_hl_event_batch = event_batches[1];
        if (error != null) {
          throw error;
        }
        for (_i = 0, _len = tidal_hl_event_batch.length; _i < _len; _i++) {
          tidal_event = tidal_hl_event_batch[_i];
          row_idx += 1;
          lunar_events = tidal_event['lunar-events'];
          _ref = _this._get_moon_phase(lunar_events), moon_quarter = _ref[0], moon_symbol = _ref[1];
          _ref1 = _this._get_moon_distance(lunar_events), ap = _ref1[0], ap_symbol = _ref1[1], distance_ed = _ref1[2];
          _ref2 = _this._get_moon_declination(lunar_events), sn = _ref2[0], sn_symbol = _ref2[1], declination_deg = _ref2[2];
          date = tidal_event['date'];
          this_day = date.date();
          this_month = date.month();
          if (!wrote_header) {
            _ref3 = _this.format_month_name(page_nr, date), this_month_tex = _ref3[0], chapter_mark = _ref3[1];
            echo(TEX.rpr(chapter_mark));
            wrote_header = true;
          }
          if (moon_quarter === 0 || moon_quarter === 2) {

            /* TAINT collect these in a 'newpage' function */
            row_idx = 0;
            page_nr += 1;
            (function(page_nr, dots) {
              if (page_nr < 80) {

                /* TAINT asynchronous handling is missing */
                info("drawing image " + page_nr);
                route = njs_path.join('/tmp', "tides-p" + page_nr + ".png");
                echo("\\paTopLeft*{0mm}{0mm}{\\includegraphics[width=118mm]{" + route + "}}");
                return _this.draw_curves(route, dots, function(error) {
                  info("image " + page_nr + " ok");
                  if (error != null) {
                    throw error;
                  }
                });
              }
            })(page_nr, dots);
            _ref4 = _this.format_month_name(page_nr, date), this_month_tex = _ref4[0], chapter_mark = _ref4[1];
            echo(TEX.rpr(chapter_mark));
            dots = _this._new_dots();
            delete dots['month-change-at-row-idx'];
            delete dots['month-change-at-hl'];
            echo("\\null\\newpage");
            wrote_header = false;
          }

          /* TAINT parametrize */

          /* TAINT measurements should be defined in options */
          textheight = 178;
          line_count = 62;
          module = textheight / line_count;
          unit = 'mm';
          y_position = _this._y_position_from_row_idx(row_idx, module, unit);

          /* TAINT take horizontal positions from options */
          symbols = [];
          if (sn != null) {
            symbols.push(sn_symbol);
          }
          if (ap != null) {
            symbols.push(ap_symbol);
          }
          if (moon_symbol != null) {
            symbols.push(moon_symbol);
          }
          if (symbols.length > 0) {
            symbols = symbols.join('');
            echo("\\paLeftGauge{0.5mm}{" + y_position + "}{" + symbols + "}");
          }
          hl = tidal_event['hl'];
          if (last_day !== this_day) {
            last_day = this_day;
            month_txt = date.format('MM');
            day_txt = date.format('DD');
            weekday_txt = (date.format('dd')).toLowerCase();
            color = (function() {
              switch (date.day()) {
                case 0:
                  return FI.get(TIDES.options, '/values/colors/red');
                default:
                  return FI.get(TIDES.options, '/values/colors/black');
              }
            })();
            echo("\\paLeftGauge{10.5mm}{" + y_position + "}{\\textcolor[HTML]{" + color + "}{\\itFont{}" + weekday_txt + "}}");
            echo("\\paRightGauge{22.5mm}{" + y_position + "}{\\textcolor[HTML]{" + color + "}{\\large{} " + day_txt + ".}}");
            _this._add_dots_day_entry(dots, row_idx, this_day, hl);
          }
          if (last_month !== this_month) {
            dots['month-change-at-row-idx'] = row_idx;
            dots['month-change-at-hl'] = hl;
            last_month = this_month;
            echo("\\typeout{\\trmSolCyan{" + (date.format('YYYY-MM-DD')) + "}}");
            echo("\\typeout{\\trmSolCyan{" + (date.format('MMM')) + "}}");
          }
          height = tidal_event['height'];
          dots.push([hl, [height, dots.length]]);
          switch (hl) {
            case 'h':
              x_position = '34mm';
              break;
            case 'l':
              x_position = '46mm';
              break;
            default:
              throw new Error("expected `h` or `l` for hl indicator, got " + (rpr(hl)));
          }

          /* TAINT use proper escaping */
          dst = tidal_event['is-dst'] ? '+' : '';
          time_txt = date.format("HH[" + thinspace + "]:[" + thinspace + "]mm");
          echo("\\paRightGauge{" + x_position + "}{" + y_position + "}{" + time_txt + "}");
        }
        return echo(postscript);
      };
    })(this));
    return null;
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);
