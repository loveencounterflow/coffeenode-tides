// Generated by CoffeeScript 1.6.3
(function() {
  var TEX, TIDES, TRM, TYPES, alert, badge, cline, debug, echo, esc, eventually, hbox, help, hline, hrule, info, leading, leavevmode, log, multicolumn, newline, next_cell, next_line, njs_fs, njs_path, postscript, preamble, read, rpr, thinspace, warn, whisper,
    __slice = [].slice;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/write-tex';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  eventually = process.nextTick;

  TEX = require('jizura-xelatex');

  TIDES = require('./main');

  this.draw_curves_with_hobby = require('./draw-curves-with-gm');

  read = function(route) {
    return njs_fs.readFileSync(njs_path.join(__dirname, route), {
      encoding: 'utf-8'
    });
  };

  preamble = read('../tex-inputs/preamble.tex');

  postscript = read('../tex-inputs/postscript.tex');

  this._as_integer = function(hint) {
    return parseInt(hint, 10);
  };

  leavevmode = TEX.make_command('leavevmode');

  hbox = TEX.make_command('hbox');

  leading = TEX.make_command('leading');

  multicolumn = TEX.make_multicommand('multicolumn', 3);

  hrule = TEX.raw("\n\n\\hrule\n\n");

  hline = TEX.raw("\n\\hline\n");

  cline = TEX.make_command('cline');

  this.new_tabular = TEX.make_environment('tabular');

  next_line = TEX.raw('\\\\\n');

  newline = TEX.raw('\n');

  next_cell = TEX.raw(' & ');

  esc = TEX._escape.bind(TEX);

  thinspace = TEX.raw('$\\thinspace$');

  thinspace = '\u2009';

  this.moon_symbols = {
    'unicode': ['⬤', '◐', '◯', '◑'],
    'plain': [TEX.raw('\\newmoon'), TEX.raw('\\rightmoon'), TEX.raw('\\fullmoon'), TEX.raw('\\leftmoon')]
  };

  this.weekday_names = {
    'dutch': {
      'full': ['maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag', 'zondag'],
      'abbreviated': ['ma', 'di', 'wo', 'do', 'vr', 'za', 'zo']
    }
  };

  this.month_names = {
    'dutch': {
      'full': ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
      'abbreviated': ['jan', 'feb', 'maart', 'apr', 'mei', 'juni', 'juli', 'aug', 'sept', 'oct', 'nov', 'dec']
    }
  };

  this.get_month_name = function(month, language, style) {
    var R, _ref, _ref1;
    if (!TYPES.isa_number(month)) {
      month = parseInt(month, 10);
    }
    R = (_ref = this.month_names[language]) != null ? (_ref1 = _ref[style]) != null ? _ref1[month - 1] : void 0 : void 0;
    if (R == null) {
      throw new Error("unable to understand month specification  " + (rpr(month)) + ", " + (rpr(language)) + ", " + (rpr(style)));
    }
    return R;
  };

  this.format_month = function(month) {
    month = this.get_month_name(month, 'dutch', 'abbreviated');
    month = month[0].toUpperCase() + month.slice(1);
    return TEX.new_group([TEX.new_command('color', 'DarkRed'), TEX.new_loner('scFont'), TEX.new_loner('large'), ' ', month]);
  };

  this.new_row = function(table_row) {
    var R, add, day, moon_quarter, time, weekday_idx, weekday_name;
    R = TEX.new_container([]);
    add = function() {
      var P, p, _i, _len;
      P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (_i = 0, _len = P.length; _i < _len; _i++) {
        p = P[_i];
        TEX.push(R, p);
      }
      return R;
    };
    if (table_row['is-new-day']) {
      add(cline('2-4'));
    }
    if (table_row['day-change']) {
      add(cline('5-5'));
    }
    if ((moon_quarter = table_row['moon-quarter']) != null) {
      add(this.moon_symbols['plain'][moon_quarter]);
    }
    add(next_cell);
    if (table_row['date'] != null) {
      day = table_row['date'][2];
      add(TEX.new_group([TEX.new_loner('itFont'), day]));
      add('.');
    }
    add(next_cell);
    if (table_row['date'] != null) {
      weekday_idx = table_row['weekday-idx'];
      weekday_name = this.weekday_names['dutch']['abbreviated'][weekday_idx];

      /* TAINT use TeX commands for formatting */
      switch (weekday_idx) {
        case 6:

          /* TAINT color repeated here */
          add(TEX.new_group([TEX.new_command('color', 'DarkRed'), TEX.new_loner('itFont'), weekday_name]));
          break;
        default:
          add(TEX.new_group([TEX.new_loner('itFont'), weekday_name]));
      }
    }
    add(next_cell);
    if ((time = table_row['hi-water-time']) != null) {
      add(time[0], thinspace, ':', thinspace, time[1]);
    }
    add(next_cell);
    if ((time = table_row['lo-water-time']) != null) {
      add(time[0], thinspace, ':', thinspace, time[1]);
    }
    add(next_cell);
    add(next_line);
    return R;
  };

  this.draw_curves = function(hi_dots, lo_dots, handler) {
    var method;
    warn("`write-tex#draw_curves` must use options object; not yet implemented");
    return handler(null, 'CURVES OMITTED');
    method = this["draw_curves_with_" + image_format];
    if (method == null) {
      throw new Error("unknown image format " + image_format);
    }
    method = method.bind(this);
    return method(hi_dots, lo_dots, handler);
  };

  this.draw_curves_with_hobby = function(hi_dots, lo_dots, handler) {

    /* Given the series for line indices and water level maxima and minima (in cm relative to LAT), return
    a LaTeX snippet to generate curves using the `hobby` package.
    
    **Note** This code is no longer maintained and has been left here for future reference only. It is
    somehwat slow and conceptually more difficult to get right than using the `gm` module; it also does not
    allow to easily cache results between runs, so all the computation has to be done on each run anew.
    It also violates the principle that computation-heavy stuff with complex logics should be done outside
    of LaTeX, which is not really built to do that kind of stuff.
     */
    var R, collection, dot_txt, dots, first_dot, height, idx, last_dot, _i, _j, _len, _len1, _ref, _ref1;
    throw new Error("code no longer maintained; please read comments in\n`src/main.coffee#draw_curves_with_hobby` to learn why.");
    R = TEX.new_container([]);
    TEX.push(R, TEX.raw("\\begin{tikzpicture}[scale=1,x=0.1mm,y=-1em]%\n"));
    _ref = [hi_dots, lo_dots];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      collection = _ref[_i];
      dots = [];
      for (_j = 0, _len1 = collection.length; _j < _len1; _j++) {
        _ref1 = collection[_j], idx = _ref1[0], height = _ref1[1];
        dot_txt = "(" + height + "," + idx + ")";
        TEX.push(R, TEX.raw("\\filldraw " + dot_txt + " circle (1pt);%\n"));
        dots.push(dot_txt);
      }
      first_dot = dots.shift();
      last_dot = dots.pop();
      TEX.push(R, TEX.raw("\\draw " + first_dot + " to\n[ curve through ={" + (dots.join(' .. ')) + "}]\n" + last_dot + ";"));
    }
    TEX.push(R, TEX.raw("\\end{tikzpicture}"));
    return R;
  };


  /*
  \multicolumn{3}{l}{{\color{DarkRed}\scFont\large Januari} 2014} & H & L & \\
  
  \draw ([in angle=90, out angle=-90]99,1) to
  [ curve through ={(109,2) .. (97,3) .. (114,4) .. (93,5) .. (119,6) .. (89,7) .. (121,8) .. (85,9) .. (121,10) .. (80,11) .. (117,12) .. (75,13) .. (110,14) .. (70,15) .. (100,16) .. (66,17) .. (89,18) .. (63,19) .. (80,20) .. (65,21) .. (77,22) .. (74,23) .. (79,24) .. (85,25) .. (82,26) .. (93,27) .. (81,28) .. (97,29) .. (79,30) .. (100,31) .. (79,32) .. (103,33) .. (79,34) .. (105,35) .. (79,36) .. (105,37) .. (77,38) .. (102,39) .. (74,40) .. (98,41) .. (70,42) .. (94,43) .. (67,44) .. (89,45) .. (64,46) .. (83,47) .. (61,48) .. (77,49) .. (62,50) .. (75,51) .. (72,52) .. (80,53) .. (86,54) .. (86,55) .. (99,56) .. (89,57) .. (109,58) .. (89,59) .. (115,60) .. (88,61) .. (119,62) .. (87,63) .. (121,64) .. (85,65) .. (119,66) .. (82,67) .. (112,68) .. (78,69) .. (101,70)}]
  (72,71);
  \draw ([in angle=90, out angle=-90]-106,0) to
  [ curve through ={(-109,1) .. (-113,2) .. (-113,3) .. (-118,4) .. (-117,5) .. (-121,6) .. (-120,7) .. (-121,8) .. (-122,9) .. (-118,10) .. (-120,11) .. (-110,12) .. (-115,13) .. (-101,14) .. (-106,15) .. (-90,16) .. (-95,17) .. (-81,18) .. (-86,19) .. (-76,20) .. (-83,21) .. (-79,22) .. (-87,23) .. (-86,24) .. (-94,25) .. (-93,26) .. (-98,27) .. (-97,28) .. (-99,29) .. (-100,30) .. (-99,31) .. (-103,32) .. (-101,33) .. (-107,34) .. (-103,35) .. (-110,36) .. (-103,37) .. (-109,38) .. (-102,39) .. (-107,40) .. (-99,41) .. (-103,42) .. (-95,43) .. (-100,44) .. (-92,45) .. (-94,46) .. (-87,47) .. (-88,48) .. (-84,49) .. (-85,50) .. (-86,51) .. (-90,52) .. (-94,53) .. (-100,54) .. (-103,55) .. (-111,56) .. (-112,57) .. (-121,58) .. (-121,59) .. (-128,60) .. (-128,61) .. (-131,62) .. (-134,63) .. (-131,64) .. (-137,65) .. (-126,66) .. (-135,67) .. (-117,68) .. (-127,69)}]
  (-105,70);
  
  \multirow{10}{*}{%
  \begin{tikzpicture}[scale=1,x=0.1mm,y=-3em]%
  \filldraw (0,0) circle (1pt);%
  \filldraw (-100,1) circle (1pt);%
  \filldraw (100,2) circle (1pt);%
  \filldraw (1,3) circle (1pt);%
  \filldraw (3,4) circle (1pt);%
  \filldraw (3,5) circle (1pt);%
  \draw (0,0) to [ quick curve through ={(-100,1) .. (100,2) .. (1,3) .. (3,4)}] (3,5);%
  \end{tikzpicture}} \\
   */

  this.y_position_from_datetime = function(row_idx, day_idx, time, module, unit) {
    var value;
    if (unit == null) {
      unit = 'mm';
    }

    /* TAINT use proper units datatype */

    /* TAINT make prescision configurable */
    value = (row_idx + 1) * module;
    value = value.toFixed(2);
    return "" + value + unit;
  };

  this.main = function() {

    /* TAINT must parametrize data source */
    var day_idx, hi_dots, last_day, lo_dots, moon_quarter, route, row_idx, rows, wrote_header;
    route = njs_path.join(__dirname, '../tidal-data/Yerseke.txt');
    rows = TEX.new_container([]);
    row_idx = -1;
    day_idx = -1;
    hi_dots = [];
    lo_dots = [];
    last_day = null;
    moon_quarter = null;
    wrote_header = false;
    echo(preamble);
    return TIDES.walk_tidal_records(route, (function(_this) {
      return function(error, trc) {
        var hl, this_date, this_day, this_month, this_month_tex, this_time, this_year, x_position, y_position;
        if (error != null) {
          throw error;
        }
        if (trc === null) {
          echo(postscript);
          return;
        }
        row_idx += 1;
        this_date = trc['date'];
        this_time = trc['time'];
        this_year = this_date[0], this_month = this_date[1], this_day = this_date[2];
        if (this_month !== ' 1') {
          return null;
        }
        if (!wrote_header) {
          this_month_tex = _this.format_month(this_month);
          wrote_header = true;
        }
        y_position = _this.y_position_from_datetime(row_idx, day_idx, this_time, 3, 'mm');
        if (last_day !== this_day) {
          last_day = this_day;
          day_idx += 1;

          /* TAINT days y to be adjusted */
          echo("\\paRight{20mm}{" + y_position + "}{" + this_date[2] + "}");
        }
        switch (hl = trc['hl']) {
          case 'h':
            x_position = '40mm';
            break;
          case 'l':
            x_position = '55mm';
            break;
          default:
            throw new Error("expected `h` or `l` for hl indicator, got " + (rpr(hl)));
        }

        /* TAINT use proper escaping */
        return echo("\\paRight{" + x_position + "}{" + y_position + "}{" + this_time[0] + " : " + this_time[1] + "}");
      };
    })(this));
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);
