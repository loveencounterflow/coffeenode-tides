// Generated by CoffeeScript 1.7.1
(function() {
  var BAP, TEX, TEXT, TIDES, TRM, TYPES, alert, badge, debug, echo, esc, hbox, help, info, leading, leavevmode, log, multicolumn, newline, njs_fs, njs_path, paCenter, paCenterGauge, paLeft, paLeftGauge, paRight, paRightGauge, postscript, preamble, read, rpr, thinspace, warn, whisper;

  njs_fs = require('fs');

  njs_path = require('path');

  BAP = require('coffeenode-bitsnpieces');

  TYPES = require('coffeenode-types');

  TEXT = require('coffeenode-text');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/write-tex';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  TEX = require('jizura-xelatex');

  TIDES = require('./main');

  this._draw_curves_with_gm = require('./draw-curves-with-gm');

  read = function(route) {
    return njs_fs.readFileSync(njs_path.join(__dirname, route), {
      encoding: 'utf-8'
    });
  };

  preamble = read('../tex-inputs/preamble.tex');

  postscript = read('../tex-inputs/postscript.tex');

  this._as_integer = function(hint) {
    return parseInt(hint, 10);
  };

  leavevmode = TEX.make_command('leavevmode');

  hbox = TEX.make_command('hbox');

  leading = TEX.make_command('leading');

  multicolumn = TEX.make_multicommand('multicolumn', 3);

  paLeft = TEX.make_multicommand('paLeft', 3);

  paCenter = TEX.make_multicommand('paCenter', 3);

  paRight = TEX.make_multicommand('paRight', 3);

  paLeftGauge = TEX.make_multicommand('paLeftGauge', 3);

  paCenterGauge = TEX.make_multicommand('paCenterGauge', 3);

  paRightGauge = TEX.make_multicommand('paRightGauge', 3);

  newline = TEX.raw('\n');

  esc = TEX._escape.bind(TEX);

  thinspace = '\u2009';

  this.format_month_name = function(date) {

    /* TAINT make formats configurable */
    var align_x, align_y, alignment, content, month_name, pa_command, position_x, position_y;
    month_name = date.format('MMMM');
    month_name = month_name[0].toUpperCase() + month_name.slice(1);

    /* TAINT inefficient to retrieve each time; options should use cache */
    align_x = TIDES.options.get('/values/layout/month/odd/align/x');
    align_y = TIDES.options.get('/values/layout/month/odd/align/y');
    position_x = (TIDES.options.get('/values/layout/month/odd/position/x')) + 'mm';
    position_y = (TIDES.options.get('/values/layout/month/odd/position/y')) + 'mm';
    switch (alignment = align_x) {
      case 'left':
        pa_command = paLeftGauge;
        break;
      case 'center':
        pa_command = paCenterGauge;
        break;
      case 'right':
        pa_command = paRightGauge;
        break;
      default:
        throw new Error("unknown alignment " + (rpr(alignment)));
    }
    content = TEX.new_group([TEX.new_loner('scFont'), TEX.new_loner('large'), TEX.new_command('color', 'DarkRed'), month_name]);
    return pa_command([position_x, position_y, content]);
  };

  this.draw_curves = function(page_nr, dots, handler) {
    return this._draw_curves_with_gm(page_nr, dots, handler);
  };

  this._y_position_from_row_idx = function(row_idx, module, unit) {
    var value;
    if (unit == null) {
      unit = 'mm';
    }

    /* TAINT make configurable */

    /* TAINT use proper units datatype */
    value = (row_idx + 1) * module;
    value = value.toFixed(2);
    return "" + value + unit;
  };

  this.main = function() {

    /* TAINT must parametrize data source */
    var dots, last_day, last_month, last_year, moon_quarter, page_nr, route, row_idx, rows, wrote_header;
    route = njs_path.join(__dirname, '../tidal-data/Yerseke.txt');
    rows = TEX.new_container([]);
    row_idx = -1;
    dots = [];
    page_nr = 0;
    last_day = null;
    last_month = null;
    last_year = null;
    moon_quarter = null;
    wrote_header = false;
    echo(preamble);
    return TIDES.walk(route, (function(_this) {
      return function(error, tide_event) {
        var date, day_txt, dst, height, hl, line_count, module, month_txt, moon_event, moon_symbol, textheight, this_day, this_month, this_month_tex, time_txt, unit, x_position, y_position;
        if (error != null) {
          throw error;
        }
        if (tide_event === null) {
          echo(postscript);
          return;
        }
        row_idx += 1;
        moon_event = tide_event['moon'];
        date = tide_event['date'];
        this_day = date.date();
        this_month = date.month();
        if (!wrote_header) {
          this_month_tex = _this.format_month_name(date);
          echo(TEX.rpr(this_month_tex));
          wrote_header = true;
        }
        if ((moon_quarter = tide_event['moon-quarter']) != null) {
          if (moon_quarter === 0 || moon_quarter === 2) {

            /* TAINT collect these in a 'newpage' function */
            row_idx = 0;
            page_nr += 1;
            (function(page_nr, dots) {
              if (page_nr < 3) {

                /* TAINT asynchronous handling is missing */
                info("drawing image " + page_nr);
                route = njs_path.join('/tmp', "tides-p" + page_nr + ".png");
                echo("\\paTopLeft*{0mm}{0mm}{\\includegraphics[width=118mm]{" + route + "}}");
                return _this.draw_curves(route, dots, function(error) {
                  info("image " + page_nr + " ok");
                  if (error != null) {
                    throw error;
                  }
                });
              }
            })(page_nr, dots);
            dots = [];
            echo("\\null\\newpage");
          }
        }

        /* TAINT measurements should be defined in options */
        textheight = 178;
        line_count = 62;
        module = textheight / line_count;
        unit = 'mm';
        y_position = _this._y_position_from_row_idx(row_idx, module, unit);

        /* TAINT Unfortunate solution to again ask for moon quarter */
        if (moon_quarter != null) {
          moon_symbol = TIDES.options.get("/values/moon/" + moon_quarter);
          echo("\\paRight{10mm}{" + y_position + "}{" + moon_symbol + "}");
        }
        if (last_day !== this_day) {
          last_day = this_day;

          /* TAINT days y to be adjusted */
          month_txt = date.format('MM');
          day_txt = date.format('DD');
          echo("\\paRight{20mm}{" + y_position + "}{" + month_txt + "-" + day_txt + "}");
        }
        if (last_month !== this_month) {
          last_month = this_month;
          echo("\\typeout{\\trmSolCyan{" + (date.format('YYYY-MM-DD')) + "}}");
        }
        hl = tide_event['hl'];
        height = tide_event['height'];
        dots.push([hl, [height, dots.length]]);
        switch (hl) {
          case 'h':
            x_position = '40mm';
            break;
          case 'l':
            x_position = '90mm';
            break;
          default:
            throw new Error("expected `h` or `l` for hl indicator, got " + (rpr(hl)));
        }

        /* TAINT use proper escaping */
        dst = tide_event['is-dst'] ? '+' : '';
        time_txt = date.format("HH[" + thinspace + "]:[" + thinspace + "]mm");
        return echo("\\paRight{" + x_position + "}{" + y_position + "}{" + time_txt + "}");
      };
    })(this));
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);
