// Generated by CoffeeScript 1.7.1
(function() {
  var GM, TRM, TYPES, alert, badge, debug, echo, f, help, info, log, njs_fs, njs_path, options, rpr, warn, whisper, x;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/draft';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  GM = require('gm');

  options = {
    'pixels-per-mm': 15,
    'width.mm': 118,
    'height.mm': 178,
    'width.px': null,
    'height.px': null,

    /* TAINT this value from `write-tex#module` */
    'line-height.mm': 2.871,
    'line-height.px': null,
    'x-offset.mm': 90,
    'x-offset.px': null
  };

  this._compile_options = function(options) {
    options['width.px'] = options['width.mm'] * options['pixels-per-mm'];
    options['height.px'] = options['height.mm'] * options['pixels-per-mm'];
    options['line-height.px'] = options['line-height.mm'] * options['pixels-per-mm'];
    return options['x-offset.px'] = options['x-offset.mm'] * options['pixels-per-mm'];
  };

  this._image_px_from_origin_mm = function(d_mm) {
    return d_mm * options['pixels-per-mm'];
  };

  this._image_px_from_real_cm = function(x_real_cm) {

    /* TAINT magic number 14 */
    return options['x-offset.px'] - x_real_cm * options['pixels-per-mm'] / 14;
  };

  this._image_px_from_y_raw = function(y_raw) {

    /* TAINT make configurable */
    return (0.75 + y_raw) * options['line-height.px'];
  };

  this._convert_dots_to_mm = function(raw_dots) {
    var R, hl, idx, raw_dot, x, x_real_cm, y, y_raw, _i, _len, _ref;
    R = [];
    for (idx = _i = 0, _len = raw_dots.length; _i < _len; idx = ++_i) {
      raw_dot = raw_dots[idx];
      hl = raw_dot[0], (_ref = raw_dot[1], x_real_cm = _ref[0], y_raw = _ref[1]);
      x = this._image_px_from_real_cm(x_real_cm);
      y = this._image_px_from_y_raw(y_raw);
      R.push([hl, [x, y]]);
    }
    return R;
  };

  this._get_control_points_for_vertical_bezier = function(point0, point3) {
    var x0, x1, x2, x3, y0, y1, y2, y3;
    x0 = point0[0], y0 = point0[1];
    x3 = point3[0], y3 = point3[1];
    y1 = y2 = Math.floor((y0 + y3) / 2 + 0.5);
    x1 = x0;
    x2 = x3;
    return [[x1, y1], [x2, y2]];
  };

  module.exports = this._draw_curves_with_gm = function(route, raw_dots, handler) {

    /* Given the series for line indices and water level maxima and minima (in cm relative to LAT), return
    a LaTeX snippet to include the respective image file. Missing image files will be generated on the fly.
     */
    var bezier_h_points, bezier_l_points, bezier_tide_points, dot0, dot3, dots, hl, hl0, hl3, idx, image, point0, point1, point2, point3, points, x0, x1, y0, y1, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    bezier_tide_points = [];
    bezier_h_points = [];
    bezier_l_points = [];
    dots = this._convert_dots_to_mm(raw_dots);
    for (idx = _i = 0, _len = dots.length; _i < _len; idx = ++_i) {
      dot0 = dots[idx];
      hl0 = dot0[0], point0 = dot0[1];
      dot3 = raw_dots[idx + 1];
      if (dot3 == null) {
        break;
      }
      hl3 = dot3[0], point3 = dot3[1];
      _ref = this._get_control_points_for_vertical_bezier(point0, point3), point1 = _ref[0], point2 = _ref[1];
      bezier_tide_points.push([hl0, [point0, point1, point2, point3]]);
    }

    /* TAINT ratio pixels / mm should be configurable */
    image = GM(options['width.px'], options['height.px'], "#ffffffff").fontSize(68).fill('transparent').stroke("black", 2);

    /* draw LAT vertical */
    x0 = x1 = this._image_px_from_real_cm(0);
    y0 = this._image_px_from_y_raw(0);
    y1 = this._image_px_from_y_raw(60);
    image.stroke("black", 1).drawLine(x0, y0, x1, y1);

    /* draw NAP vertical */

    /* TAINT must get NAP - LAT difference from RWS for each location */
    x0 = x1 = this._image_px_from_real_cm(0 + 203);
    y0 = this._image_px_from_y_raw(0);
    y1 = this._image_px_from_y_raw(60);
    image.stroke("black", 1).drawLine(x0, y0, x1, y1);
    for (idx = _j = 0, _len1 = bezier_tide_points.length; _j < _len1; idx = ++_j) {
      _ref1 = bezier_tide_points[idx], hl = _ref1[0], points = _ref1[1];
      (_ref2 = image.stroke("black", 1)).drawBezier.apply(_ref2, points);

      /* draw HL horizontal */
      if (idx === 0) {
        x0 = this._image_px_from_real_cm(0);
      } else {
        x0 = points[0][0];
      }

      /* TAINT these numbers also in `write-tex`; save in options */
      x1 = this._image_px_from_origin_mm((hl === 'h' ? 40 : 55) + 1);
      y0 = y1 = points[0][1];
      image.stroke("black", 1).drawLine(x0, y0, x1, y1);
    }
    image.write(route, function(error) {
      if (error != null) {
        return handler(error);
      }
      return handler(null);
    });
    return null;
  };

  this._compile_options(options);

  module.exports = module.exports.bind(this);

  x = 42;

  f = function() {
    return f((function(_this) {
      return function(error, result, x) {
        x = 108;
        return null;
      };
    })(this));
  };

}).call(this);
