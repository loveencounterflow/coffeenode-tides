// Generated by CoffeeScript 1.7.1
(function() {
  var GM, TRM, TYPES, alert, badge, debug, echo, f, help, info, log, njs_fs, njs_path, options, rpr, warn, whisper, x,
    __slice = [].slice;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/draft';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  GM = require('gm');

  options = {
    'pixels-per-mm': 15,
    'width.mm': 118,
    'height.mm': 178,
    'width.px': null,
    'height.px': null,

    /* TAINT this value from `write-tex#module` */
    'line-height.mm': 2.871,
    'line-height.px': null,
    'x-offset.mm': 90,
    'x-offset.px': null
  };

  this._compile_options = function(options) {
    options['width.px'] = options['width.mm'] * options['pixels-per-mm'];
    options['height.px'] = options['height.mm'] * options['pixels-per-mm'];
    options['line-height.px'] = options['line-height.mm'] * options['pixels-per-mm'];
    return options['x-offset.px'] = options['x-offset.mm'] * options['pixels-per-mm'];
  };

  this._image_px_from_origin_mm = function(d_mm) {
    return d_mm * options['pixels-per-mm'];
  };

  this._image_px_from_real_cm = function(x_real_cm) {

    /* TAINT magic number 14 */
    return options['x-offset.px'] - x_real_cm * options['pixels-per-mm'] / 14;
  };

  this._image_px_from_y_raw = function(y_raw) {

    /* TAINT make configurable */
    return (0.75 + y_raw) * options['line-height.px'];
  };

  module.exports = this._draw_curves_with_gm = function(route, raw_dots, handler) {

    /* Given the series for line indices and water level maxima and minima (in cm relative to LAT), return
    a LaTeX snippet to include the respective image file. Missing image files will be generated on the fly.
     */
    var bezier_dots, dots, hl, hl0, hl3, hl_dots, idx, image, raw_dot0, raw_dot3, x0, x0_real_cm, x1, x2, x3, x3_real_cm, y0, y0_raw, y1, y2, y3, y3_raw, _i, _j, _len, _len1, _ref, _ref1;
    bezier_dots = [];
    for (idx = _i = 0, _len = raw_dots.length; _i < _len; idx = ++_i) {
      raw_dot0 = raw_dots[idx];
      hl0 = raw_dot0[0], (_ref = raw_dot0[1], x0_real_cm = _ref[0], y0_raw = _ref[1]);
      raw_dot3 = raw_dots[idx + 1];
      if (raw_dot3 == null) {
        break;
      }
      hl3 = raw_dot3[0], (_ref1 = raw_dot3[1], x3_real_cm = _ref1[0], y3_raw = _ref1[1]);
      x0 = this._image_px_from_real_cm(x0_real_cm);
      y0 = this._image_px_from_y_raw(y0_raw);
      x3 = this._image_px_from_real_cm(x3_real_cm);
      y3 = this._image_px_from_y_raw(y3_raw);
      y1 = y2 = Math.floor((y0 + y3) / 2 + 0.5);
      x1 = x0;
      x2 = x3;
      bezier_dots.push([hl0, [x0, y0], [x1, y1], [x2, y2], [x3, y3]]);
    }

    /* TAINT ratio pixels / mm should be configurable */
    image = GM(options['width.px'], options['height.px'], "#ffffffff").fontSize(68).fill('transparent').stroke("black", 2);

    /* draw LAT vertical */
    x0 = x1 = this._image_px_from_real_cm(0);
    y0 = this._image_px_from_y_raw(0);
    y1 = this._image_px_from_y_raw(60);
    image.drawLine(x0, y0, x1, y1);

    /* draw NAP vertical */

    /* TAINT must get NAP - LAT difference from RWS for each location */
    x0 = x1 = this._image_px_from_real_cm(0 + 203);
    y0 = this._image_px_from_y_raw(0);
    y1 = this._image_px_from_y_raw(60);
    image.drawLine(x0, y0, x1, y1);
    for (idx = _j = 0, _len1 = bezier_dots.length; _j < _len1; idx = ++_j) {
      hl_dots = bezier_dots[idx];
      hl = hl_dots[0], dots = 2 <= hl_dots.length ? __slice.call(hl_dots, 1) : [];
      image.drawBezier.apply(image, dots);

      /* draw HL horizontal */
      if (idx === 0) {
        x0 = this._image_px_from_real_cm(0);
      } else {
        x0 = dots[0][0];
      }

      /* TAINT these numbers also in `write-tex`; save in options */
      x1 = this._image_px_from_origin_mm((hl === 'h' ? 40 : 55) + 1);
      y0 = y1 = dots[0][1];
    }
    image.write(route, function(error) {
      if (error != null) {
        return handler(error);
      }
      return handler(null);
    });
    return null;
  };

  this._compile_options(options);

  module.exports = module.exports.bind(this);

  x = 42;

  f = function() {
    return f((function(_this) {
      return function(error, result, x) {
        x = 108;
        return null;
      };
    })(this));
  };

}).call(this);
