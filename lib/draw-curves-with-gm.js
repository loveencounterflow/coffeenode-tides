// Generated by CoffeeScript 1.7.1
(function() {
  var FI, GM, TIDES, TRM, TYPES, alert, badge, debug, echo, f, help, info, log, njs_fs, njs_path, options, rpr, warn, whisper, x;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIDES/draft';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  TIDES = require('./main');

  GM = require('gm');

  FI = require('coffeenode-fillin');


  /* TAINT must go into TIDES/options */

  options = {
    'pixels-per-mm': 15,
    'width.mm': 118,
    'height.mm': 178,
    'width.px': null,
    'height.px': null,

    /* TAINT this value from `write-tex#module` */
    'line-height.mm': 2.871,
    'line-height.px': null,
    'x-offset.mm': 90,
    'x-offset.px': null
  };

  this._compile_options = function(options) {
    options['width.px'] = options['width.mm'] * options['pixels-per-mm'];
    options['height.px'] = options['height.mm'] * options['pixels-per-mm'];
    options['line-height.px'] = options['line-height.mm'] * options['pixels-per-mm'];
    return options['x-offset.px'] = options['x-offset.mm'] * options['pixels-per-mm'];
  };

  this._image_px_from_origin_mm = function(d_mm) {
    return d_mm * options['pixels-per-mm'];
  };

  this._image_px_from_real_cm = function(x_real_cm) {

    /* TAINT magic number 14 */
    return options['x-offset.px'] - x_real_cm * options['pixels-per-mm'] / 14;
  };

  this._image_px_from_y_raw = function(y_raw) {

    /* TAINT make configurable */
    return (0.75 + y_raw) * options['line-height.px'];
  };

  this._dots_mm_from_raw_dots = function(raw_dots) {
    var R, hl, idx, raw_dot, x, x_real_cm, y, y_raw, _i, _len, _ref;
    R = [];
    for (idx = _i = 0, _len = raw_dots.length; _i < _len; idx = ++_i) {
      raw_dot = raw_dots[idx];
      hl = raw_dot[0], (_ref = raw_dot[1], x_real_cm = _ref[0], y_raw = _ref[1]);
      x = this._image_px_from_real_cm(x_real_cm);
      y = this._image_px_from_y_raw(y_raw);
      R.push([hl, [x, y]]);
    }
    return R;
  };

  this._get_control_points_for_vertical_bezier = function(point0, point3) {
    var x0, x1, x2, x3, y0, y1, y2, y3;
    x0 = point0[0], y0 = point0[1];
    x3 = point3[0], y3 = point3[1];
    y1 = y2 = Math.floor((y0 + y3) / 2 + 0.5);
    x1 = x0;
    x2 = x3;
    return [[x1, y1], [x2, y2]];
  };

  this._get_hl_points_from_dots = function(dots) {
    var R, dot0, dot3, hl0, hl3, idx, point0, point1, point2, point3, _i, _len, _ref;
    R = [];
    for (idx = _i = 0, _len = dots.length; _i < _len; idx = ++_i) {
      dot0 = dots[idx];
      hl0 = dot0[0], point0 = dot0[1];
      dot3 = dots[idx + 1];
      if (dot3 == null) {
        break;
      }
      hl3 = dot3[0], point3 = dot3[1];
      _ref = this._get_control_points_for_vertical_bezier(point0, point3), point1 = _ref[0], point2 = _ref[1];
      R.push([hl0, [point0, point1, point2, point3]]);
    }
    return R;
  };

  module.exports = this._draw_curves_with_gm = function(route, raw_dots, handler) {

    /* Given the series for line indices and water level maxima and minima (in cm relative to LAT), return
    a LaTeX snippet to include the respective image file. Missing image files will be generated on the fly.
     */
    var bezier_h_dots, bezier_h_points, bezier_hl_points, bezier_l_dots, bezier_l_points, collection, color, dots, hl, hl3, idx, image, last_idx, name, names, names_and_colors, point, points, x0, x1, y0, y1, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    bezier_hl_points = [];
    bezier_h_dots = [];
    bezier_l_dots = [];
    bezier_h_points = [];
    bezier_l_points = [];
    dots = this._dots_mm_from_raw_dots(raw_dots);
    bezier_hl_points = this._get_hl_points_from_dots(dots);
    for (_i = 0, _len = dots.length; _i < _len; _i++) {
      _ref = dots[_i], hl = _ref[0], point = _ref[1];
      if (hl === 'h') {
        bezier_h_dots.push(['h', point]);
      } else {
        bezier_l_dots.push(['l', point]);
      }
    }
    bezier_h_points = this._get_hl_points_from_dots(bezier_h_dots);
    bezier_l_points = this._get_hl_points_from_dots(bezier_l_dots);

    /* TAINT ratio pixels / mm should be configurable */
    image = GM(options['width.px'], options['height.px'], "#ffffffff").fontSize(68).fill('transparent').stroke('black', 2);

    /* draw ( min, max ) ( h, l ) verticals */

    /* TAINT make configurable */
    names_and_colors = [[['min-l-height', 'max-l-height'], 'red'], [['min-h-height', 'max-h-height'], 'blue']];
    for (_j = 0, _len1 = names_and_colors.length; _j < _len1; _j++) {
      _ref1 = names_and_colors[_j], names = _ref1[0], color = _ref1[1];
      for (_k = 0, _len2 = names.length; _k < _len2; _k++) {
        name = names[_k];
        x0 = x1 = this._image_px_from_real_cm(FI.get(TIDES.options, "/data/extrema/tides/" + name));
        y0 = this._image_px_from_y_raw(0);
        y1 = this._image_px_from_y_raw(60);
        image.stroke(color, 1).drawLine(x0, y0, x1, y1);
      }
    }

    /* draw NAP vertical */

    /* TAINT must get NAP - LAT difference from RWS for each location */
    x0 = x1 = this._image_px_from_real_cm(0 + 203);
    y0 = this._image_px_from_y_raw(0);
    y1 = this._image_px_from_y_raw(60);
    image.stroke('black', 1).drawLine(x0, y0, x1, y1);
    last_idx = bezier_hl_points.length - 1;
    for (idx = _l = 0, _len3 = bezier_hl_points.length; _l < _len3; idx = ++_l) {
      _ref2 = bezier_hl_points[idx], hl = _ref2[0], points = _ref2[1];
      (_ref3 = image.stroke('black', 4)).drawBezier.apply(_ref3, points);

      /* draw HL horizontal */
      if (idx === 0) {
        x0 = this._image_px_from_real_cm(0);
      } else {
        x0 = points[0][0];
      }

      /* TAINT these numbers also in `write-tex`; save in options */
      x1 = this._image_px_from_origin_mm((hl === 'h' ? 35 : 50) + 1);
      y0 = y1 = points[0][1];
      image.stroke('black', 1).drawLine(x0, y0, x1, y1);
      if (idx === last_idx) {
        hl3 = hl === 'h' ? 'l' : 'h';
        x0 = points[3][0];
        x1 = this._image_px_from_origin_mm((hl3 === 'h' ? 35 : 50) + 1);
        y0 = y1 = points[3][1];
        image.stroke('black', 1).drawLine(x0, y0, x1, y1);
      }
    }
    _ref4 = [bezier_h_points, bezier_l_points];
    for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
      collection = _ref4[_m];
      for (idx = _n = 0, _len5 = collection.length; _n < _len5; idx = ++_n) {
        _ref5 = collection[idx], hl = _ref5[0], points = _ref5[1];
        (_ref6 = image.stroke('black', 1)).drawBezier.apply(_ref6, points);
      }
    }
    image.write(route, function(error) {
      if (error != null) {
        return handler(error);
      }
      return handler(null);
    });
    return null;
  };

  this._compile_options(options);

  module.exports = module.exports.bind(this);

  x = 42;

  f = function() {
    return f((function(_this) {
      return function(error, result, x) {
        x = 108;
        return null;
      };
    })(this));
  };

}).call(this);
